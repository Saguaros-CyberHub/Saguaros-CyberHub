---
- name: Crucible Module Gateway Template
  hosts: all
  become: true
  gather_facts: true

  vars:
    # Interfaces inside the LXC
    wan_if: "wan0"
    lan_if: "lan0"

    # Module subnet (/16)
    lan_cidr: "100.102.0.1/16"
    lan_gw: "100.102.0.1"
    lan_net: "100.102.0.0/16"
    lan_pool_start: "100.102.0.100"
    lan_pool_end: "100.102.255.254"
    lan_netmask: "255.255.0.0"   # /16

    # Management subnets (SSH troubleshooting access)
    mgmt_subnets:
      - "100.100.10.0/24" # Management VLAN
      - "100.100.30.0/24" # Trusted VLAN
      - "10.0.254.0/24" # Admin VPN range
    mgmt_ssh_port: 22

    # DHCP/DNS model A: clients use gateway as DNS, gateway forwards upstream
    upstream_dns: "100.100.50.1"         # internal resolver/router | will need to be modified by install.sh
    dhcp_dns_servers: ["100.102.0.1"]    # hand out gateway as DNS
    dhcp_lease_time: "12h"

    # SIEM/logging export (optional)
    siem_server: ""        # e.g., "100.102.20.50" (leave blank to disable forwarding) | will implement in a later version
    syslog_port: 514

    # Anti-breakout for lane hosts (block reaching internal/private ranges + mgmt subnets from lane)
    blocked_cidrs:
      - "10.0.0.0/8"
      - "172.16.0.0/12"
      - "192.168.0.0/16"
      - "100.64.0.0/10"
      - "10.0.254.0/24"

    # Allowed outbound traffic from lane to uplink (NEW connections)
    allow_out_tcp_ports: [80, 443, 22]
    allow_icmp_forward: true

    block_direct_dns_to_wan: true

    # Persist iptables at /etc/iptables/rules-save
    iptables_rules_path: "/etc/iptables/rules-save"

    # dnsmasq config
    dnsmasq_leasefile: "/var/lib/misc/dnsmasq.leases"
    dnsmasq_dropin_dir: "/etc/dnsmasq.d"
    dnsmasq_dropin_file: "/etc/dnsmasq.d/50-gateway.conf"

    # Chrony config
    chrony_conf_path: "/etc/chrony/chrony.conf"

    # rsyslog config (drop-in approach)
    rsyslog_dropin_dir: "/etc/rsyslog.d"
    rsyslog_dropin_file: "/etc/rsyslog.d/50-gateway.conf"

  handlers:
    - name: restart dnsmasq
      command: rc-service dnsmasq restart
      failed_when: false

    - name: restart iptables
      command: rc-service iptables restart
      failed_when: false

    - name: restart chrony
      command: rc-service chronyd restart
      failed_when: false

    - name: restart rsyslog
      command: rc-service rsyslog restart
      failed_when: false

    - name: restart sshd
      command: rc-service sshd restart
      failed_when: false

  tasks:
    # -------------------------
    # Base packages + services
    # -------------------------
    - name: Ensure required packages are installed
      apk:
        name:
          - openrc
          - iptables
          - dnsmasq
          - chrony
          - rsyslog
          - openssh
        state: present
        update_cache: true

    - name: Enable services at boot (OpenRC)
      command: rc-update add {{ item }} default
      register: rcupdate_out
      changed_when: "'added to runlevel default' in rcupdate_out.stdout"
      failed_when: false
      loop:
        - iptables
        - dnsmasq
        - chronyd
        - rsyslog
        - sshd

    # sysctl is a boot-time service on Alpine; enabling it ensures ip_forward persists across clones/reboots
    - name: Enable sysctl at boot (OpenRC)
      command: rc-update add sysctl boot
      register: rcupdate_sysctl
      changed_when: "'added to runlevel boot' in rcupdate_sysctl.stdout"
      failed_when: false

    - name: Ensure SSHD is started (so Ansible doesn't lock itself out mid-run)
      command: rc-service sshd start
      register: sshd_start
      changed_when: "'started' in sshd_start.stdout or 'Starting' in sshd_start.stdout"
      failed_when: false

    # -------------------------
    # Sysctl & SSH hardening
    # -------------------------
    - name: Enable IPv4 forwarding and disable IPv6 (sysctl.conf)
      blockinfile:
        path: /etc/sysctl.conf
        create: true
        marker: "# {mark} ANSIBLE GATEWAY SYSCTL"
        block: |
          net.ipv4.ip_forward=1
          net.ipv6.conf.all.disable_ipv6=1
          net.ipv6.conf.default.disable_ipv6=1

    - name: Apply sysctl settings
      command: sysctl -p
      changed_when: true

    # Extra safety: set it live in case the container boots without applying sysctl.conf
    - name: Ensure IPv4 forwarding is active now
      command: sysctl -w net.ipv4.ip_forward=1
      changed_when: false

    - name: Harden SSH daemon (key-only access)
      blockinfile:
        path: /etc/ssh/sshd_config
        create: false
        marker: "# {mark} ANSIBLE GATEWAY SSH HARDENING"
        block: |
          PermitRootLogin prohibit-password
          PasswordAuthentication no
          ChallengeResponseAuthentication no
          UsePAM no
      notify: restart sshd

    # -------------------------
    # LAN interface addressing
    # -------------------------
    - name: Check if lan0 already has correct address
      command: ip addr show dev {{ lan_if }}
      register: lan_addr_check
      changed_when: false
      failed_when: false

    - name: Ensure lan0 has the correct /28 address (idempotent)
      shell: |
        set -e
        ip -4 addr flush dev {{ lan_if }}
        ip addr add {{ lan_cidr }} dev {{ lan_if }}
        ip link set {{ lan_if }} up
      args:
        executable: /bin/sh
      when: lan_cidr not in lan_addr_check.stdout


    # -------------------------
    # WAN interface addressing (DHCP)
    # -------------------------
    - name: Check if wan0 already has an IPv4 address
      command: ip -4 addr show dev {{ wan_if }}
      register: wan_addr_check
      changed_when: false
      failed_when: false

    - name: Bring up wan0 and request DHCP if missing
      shell: |
        set -e
        ip link set {{ wan_if }} up
        if ! ip -4 addr show dev {{ wan_if }} | grep -q "inet "; then
          # BusyBox udhcpc is present by default on Alpine
          udhcpc -i {{ wan_if }} -q -n -t 5 || true
        fi
      args:
        executable: /bin/sh
      when: '"inet " not in wan_addr_check.stdout'

    # -------------------------
    # dnsmasq (DHCP + gateway-controlled DNS forwarding)
    # -------------------------
    - name: Ensure dnsmasq.d exists
      file:
        path: "{{ dnsmasq_dropin_dir }}"
        state: directory
        mode: "0755"

    - name: Ensure dnsmasq.conf includes dnsmasq.d drop-ins
      lineinfile:
        path: /etc/dnsmasq.conf
        line: "conf-dir={{ dnsmasq_dropin_dir }},*.conf"
        create: true
        state: present

    - name: Remove legacy lane directives from /etc/dnsmasq.conf (prevent duplicates)
      replace:
        path: /etc/dnsmasq.conf
        regexp: '^(interface|bind-interfaces|dhcp-range|dhcp-option|dhcp-leasefile|no-resolv|server|log-dhcp|local-service)(=|\s).*$'
        replace: ''
      notify: restart dnsmasq
      failed_when: false
    - name: Install dnsmasq config (drop-in)
      copy:
        dest: "{{ dnsmasq_dropin_file }}"
        owner: root
        group: root
        mode: "0644"
        content: |
          # Gateway dnsmasq config (Model A)
          interface={{ lan_if }}
          bind-interfaces

          dhcp-range={{ lan_pool_start }},{{ lan_pool_end }},{{ lan_netmask }},{{ dhcp_lease_time }}
          dhcp-option=3,{{ lan_gw }}
          dhcp-option=6,{{ dhcp_dns_servers | join(',') }}

          # Gateway forwards upstream (scenario control)
          no-resolv
          server={{ upstream_dns }}

          # Hygiene + logs
          domain-needed
          bogus-priv
          log-dhcp
      notify: restart dnsmasq

    - name: Validate dnsmasq config before starting/restarting
      command: dnsmasq --test
      changed_when: false

    - name: Ensure dnsmasq is started
      command: rc-service dnsmasq start
      register: dnsmasq_start
      changed_when: "'started' in dnsmasq_start.stdout or 'Starting' in dnsmasq_start.stdout"
      failed_when: false

    # -------------------------
    # Time synchronization (chrony)
    # -------------------------
    - name: Configure chrony for NTP
      blockinfile:
        path: "{{ chrony_conf_path }}"
        create: true
        marker: "# {mark} ANSIBLE GATEWAY NTP CONFIG"
        block: |
          # Upstream NTP servers
          pool 0.alpine.pool.ntp.org iburst maxsources 3
          pool 1.alpine.pool.ntp.org iburst maxsources 3
          pool 2.alpine.pool.ntp.org iburst maxsources 3
          pool 3.alpine.pool.ntp.org iburst maxsources 3

          # Allow lane clients to query time
          allow {{ lan_net }}
      notify: restart chrony

    - name: Ensure chrony is started
      command: rc-service chronyd start
      register: chrony_start
      changed_when: "'started' in chrony_start.stdout or 'Starting' in chrony_start.stdout"
      failed_when: false

    # -------------------------
    # Logging/SIEM export (rsyslog) - optional
    # -------------------------
    - name: Ensure rsyslog drop-in directory exists
      file:
        path: "{{ rsyslog_dropin_dir }}"
        state: directory
        mode: "0755"

    # Avoid the LXC /proc/kmsg spam (non-fatal but annoying)
    - name: Disable kernel log input in rsyslog for LXC (avoid /proc/kmsg permission errors)
      copy:
        dest: "{{ rsyslog_dropin_dir }}/01-lxc-no-kmsg.conf"
        owner: root
        group: root
        mode: "0644"
        content: |
          # LXC note: /proc/kmsg is typically not accessible in containers.
          # If your base config loads imklog, it may log warnings. We don't require kernel log input here.
          # (No-op file; we rely on not loading imklog in main config.)
      notify: restart rsyslog
      failed_when: false

    - name: Configure rsyslog with conditional SIEM export (drop-in)
      copy:
        dest: "{{ rsyslog_dropin_file }}"
        owner: root
        group: root
        mode: "0644"
        content: |
          # Gateway rsyslog forwarder
          {% if siem_server %}
          *.* @@{{ siem_server }}:{{ syslog_port }}
          {% endif %}
      notify: restart rsyslog

    - name: Ensure rsyslog is started
      command: rc-service rsyslog start
      register: rsyslog_start
      changed_when: "'started' in rsyslog_start.stdout or 'Starting' in rsyslog_start.stdout"
      failed_when: false

    # -------------------------
    # iptables rules (golden state)
    # -------------------------
    - name: Build iptables rules-save content
      set_fact:
        iptables_rules_save: |
          *filter
          :INPUT DROP [0:0]
          :FORWARD DROP [0:0]
          :OUTPUT ACCEPT [0:0]

          # --- INPUT (router local) ---
          -A INPUT -i lo -j ACCEPT
          -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

          # DHCP + DNS for lane clients (to the gateway)
          -A INPUT -i {{ lan_if }} -p udp --dport 67:68 -j ACCEPT
          -A INPUT -i {{ lan_if }} -p udp --dport 53 -j ACCEPT
          -A INPUT -i {{ lan_if }} -p tcp --dport 53 -j ACCEPT

          # Allow clients to ping the gateway
          -A INPUT -i {{ lan_if }} -p icmp --icmp-type echo-request -j ACCEPT

          # Management SSH access from trusted subnets (WAN-side only)
          {% for mgmt_subnet in mgmt_subnets %}
          -A INPUT -i {{ wan_if }} -s {{ mgmt_subnet }} -p tcp --dport {{ mgmt_ssh_port }} -m conntrack --ctstate NEW -j ACCEPT
          {% endfor %}

          # --- FORWARD (lane routing) ---
          -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

          # Anti-breakout: block internal/private ranges first
          {% for cidr in blocked_cidrs %}
          -A FORWARD -i {{ lan_if }} -d {{ cidr }} -j DROP
          {% endfor %}

          {% if block_direct_dns_to_wan %}
          # Prevent DNS bypass: block lane clients from talking to WAN DNS directly
          -A FORWARD -i {{ lan_if }} -o {{ wan_if }} -p udp --dport 53 -j REJECT --reject-with icmp-port-unreachable
          -A FORWARD -i {{ lan_if }} -o {{ wan_if }} -p tcp --dport 53 -j REJECT --reject-with icmp-port-unreachable
          {% endif %}

          # Allow NEW outbound from lane -> WAN (restricted ports)
          {% for p in allow_out_tcp_ports %}
          -A FORWARD -i {{ lan_if }} -o {{ wan_if }} -p tcp --dport {{ p }} -m conntrack --ctstate NEW -j ACCEPT
          {% endfor %}

          {% if allow_icmp_forward %}
          -A FORWARD -p icmp -j ACCEPT
          {% endif %}

          # Explicitly block inbound from WAN -> LAN
          -A FORWARD -i {{ wan_if }} -o {{ lan_if }} -j DROP

          # Final allow: lane subnet may egress to WAN (DNS bypass already blocked above)
          -A FORWARD -s {{ lan_net }} -i {{ lan_if }} -o {{ wan_if }} -j ACCEPT
          COMMIT

          *nat
          :PREROUTING ACCEPT [0:0]
          :INPUT ACCEPT [0:0]
          :OUTPUT ACCEPT [0:0]
          :POSTROUTING ACCEPT [0:0]
          # NAT only the lane subnet out the uplink
          -A POSTROUTING -s {{ lan_net }} -o {{ wan_if }} -j MASQUERADE
          COMMIT

          *mangle
          :PREROUTING ACCEPT [0:0]
          :INPUT ACCEPT [0:0]
          :FORWARD ACCEPT [0:0]
          :OUTPUT ACCEPT [0:0]
          :POSTROUTING ACCEPT [0:0]
          -A FORWARD -i {{ lan_if }} -o {{ wan_if }} -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
          -A FORWARD -i {{ wan_if }} -o {{ lan_if }} -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
          COMMIT

    - name: Ensure /etc/iptables exists
      file:
        path: /etc/iptables
        state: directory
        mode: "0755"

    - name: Install persistent iptables rules-save
      copy:
        dest: "{{ iptables_rules_path }}"
        content: "{{ iptables_rules_save }}"
        owner: root
        group: root
        mode: "0600"
      notify: restart iptables

    - name: Ensure iptables service is restarted (reloads rules-save)
      command: rc-service iptables restart
      register: iptables_restart
      changed_when: "'restarted' in iptables_restart.stdout or 'Restarting' in iptables_restart.stdout or 'started' in iptables_restart.stdout"
      failed_when: false

    # -------------------------
    # Sanity checks (non-fatal)
    # -------------------------
    - name: Show interface summary
      command: ip addr show
      register: ip_show
      changed_when: false
      failed_when: false

    - name: Show dnsmasq status
      command: rc-service dnsmasq status
      register: dnsmasq_status
      changed_when: false
      failed_when: false

    - name: Show iptables FORWARD summary
      command: iptables -L FORWARD -n -v
      register: ipt_fwd
      changed_when: false
      failed_when: false

    - name: Print summaries
      debug:
        msg:
          - "{{ ip_show.stdout | default('ip addr show unavailable') }}"
          - "{{ dnsmasq_status.stdout | default('dnsmasq status unavailable') }}"
          - "{{ ipt_fwd.stdout | default('iptables output unavailable') }}"

    # -------------------------
    # IMPORTANT: flush handlers BEFORE cleanup
    # (prevents "restart dnsmasq" from firing after you stop it)
    # -------------------------
    - name: Flush handlers before cleanup
      meta: flush_handlers

    # -------------------------
    # Pre-template cleanup
    # -------------------------
    - name: Stop services for cleanup
      command: rc-service {{ item }} stop
      loop: [dnsmasq, rsyslog, chronyd]
      failed_when: false

    - name: Remove dnsmasq leases
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ dnsmasq_leasefile }}"
        - "{{ dnsmasq_leasefile }}.old"
      failed_when: false

    - name: Truncate common logs
      shell: |
        set -e
        for f in /var/log/messages /var/log/syslog /var/log/dnsmasq.log /var/log/firewall.log; do
          [ -f "$f" ] && : > "$f" || true
        done
      args:
        executable: /bin/sh

    - name: Remove SSH host keys (regen on first boot)
      file:
        path: "{{ item }}"
        state: absent
      with_fileglob:
        - /etc/ssh/ssh_host_*key*
      failed_when: false

    - name: Clear shell history and login records
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /root/.ash_history
        - /root/.bash_history
        - /var/log/wtmp
        - /var/log/btmp
      failed_when: false

    - name: Remove machine-id if present
      file:
        path: /etc/machine-id
        state: absent
      failed_when: false

    # -------------------------
    # Final shutdown for templating
    # -------------------------
    - name: Cleanly shutdown container for templating
      command: /sbin/shutdown -h now
      async: 10
      poll: 0
      changed_when: true
      failed_when: false